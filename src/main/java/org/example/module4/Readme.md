4_1 Изменить алгоритм RandomizedQuickSort так, чтобы даже при последовательностях с 
множеством повторяющихся элементов ожидаемое время выполнения стало O(nlogn).

4_2 Дана число n. Вам необходимо построить массив, на котором алгоритм быстрой сортировки 
выполнит наибольшее количество рекурсивных вызовов. При рассматриваемом отрезке l,r функции быстрой сортировки, 
считайте, что точка m выбирается по формуле m=⌊l+r/2⌋

4_3 Реализуйте алгоритм Quicksort на вашем любимом языке программирования. 
Поэкспериментируйте с производительностью различных способов выбора опорного элемента
1. В качестве опорного всегда использует первый элемент.
2. В качестве опорного всегда использует последний элемент.
3. В качестве опорного использует случайный элемент. (В этом случае необходимо выполнить алгоритм 10 раз с заданным входным массивом
   и усреднить результаты.)
4. В качестве опорного элемента использует медиану из трех. (ищем медиану множества {первый, средний, последний})

4_4 leetcode 912 то же что и 4_1

4_5 leetcode 75 то же что и 4_1

test
1. c
2. b
3. c
4. a
5. c

questions
1. Рекурсивный алгоритм для сортировки массива
   + Выбор опорного элемента
   + Разделение массива на 2 части, одна из которых меньше, а другая больше опорного элемента
   + Рекурсивный вызов алгоритма на эти 2 части массива
2. В лучшем и среднем O(nlog(n)), в худшем O(n^2)
3. Опорный элемент это элемент относительно которого будет разделяться массив. Варианты выбора:
   + Случайным образом
   + Первый элемент
   + Последний элемент
   + Элемент для которого одинаковое количество элементов больше и меньше него
4. Как обычный элемент, но при большом количестве повторов время выполнения будет расти, 
можно модифицировать алгоритм как в 4_1 для уменьшения времени работы
5. + Преимущества
     + Память, все манипуляции можно выполнять в изначальном массиве
     + Скорость, в лучшем и среднем случае O(nlog(n))
   + Недостатки
     + Скорость, в худшем случае O(n^2)
6. 4_1, 4_3, Arrays.sort()
7. Когда важен объем занимаемой памяти